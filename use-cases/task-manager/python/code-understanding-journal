Main Components Involved
Task Creation:

CLI Layer (cli.py) - Command parser and user input handling
Business Logic Layer (app.py - TaskManager class) - Orchestration and validation
Model Layer (models.py - Task class) - Data structure and behavior
Storage Layer (storage.py - TaskStorage class) - Persistence and retrieval

Status Updates:

Same layers, slightly different flow through update_task_status() method
Special handling for "DONE" status via mark_as_done()


Execution Flow: Task Creation
User runs: python -m task_manager.cli create "Buy milk" -p 3 -d "2026-02-26"
                              ‚Üì
1. CLI (cli.py:57-65)
   - argparse captures: title, description, priority, due_date, tags
   - Converts tags from comma-separated string to list
                              ‚Üì
2. TaskManager.create_task() (app.py:11-25)
   - Converts priority_value (int) ‚Üí TaskPriority enum
   - Parses due_date_str ‚Üí datetime object (validates format)
   - Creates Task instance
   - Calls storage.add_task()
   - Returns task_id
                              ‚Üì
3. Task.__init__() (models.py:16-27)
   - Generates unique UUID
   - Sets status = TaskStatus.TODO (default)
   - Sets created_at = now
   - Stores all attributes
                              ‚Üì
4. TaskStorage.add_task() (storage.py:66-69)
   - Adds task to in-memory dict: self.tasks[task.id] = task
   - Calls self.save()
                              ‚Üì
5. TaskStorage.save() (storage.py:57-62)
   - Serializes tasks dict ‚Üí JSON using TaskEncoder
   - Writes to tasks.json file
                              ‚Üì
CLI prints: "Created task with ID: <uuid>"

Execution Flow: Status Update
User runs: python -m task_manager.cli status abc123 done
                              ‚Üì
1. CLI (cli.py:94-98)
   - Captures task_id and new status string
   - Calls task_manager.update_task_status()
                              ‚Üì
2. TaskManager.update_task_status() (app.py:37-47)
   - Converts status string ‚Üí TaskStatus enum
   
   **Special Case: If status == DONE:**
      - Gets task from storage
      - Calls task.mark_as_done()  ‚Üê Sets completed_at timestamp
      - Calls storage.save() directly
   
   **Normal Case: Any other status:**
      - Calls storage.update_task(task_id, status=new_status)
                              ‚Üì
3a. Task.mark_as_done() (models.py:36-39)
   - Sets self.status = TaskStatus.DONE
   - Sets self.completed_at = datetime.now()
   - Sets self.updated_at = now
                              ‚Üì
3b. TaskStorage.update_task() (storage.py:71-77)
   - Gets task from dict
   - Calls task.update(**kwargs) ‚Üê Generic update method
   - Calls self.save()
                              ‚Üì
4. Task.update() (models.py:32-35)
   - Uses setattr() to update any attribute
   - Always updates self.updated_at = now
                              ‚Üì
CLI prints: "Updated task status to done"

Data Storage & Retrieval
In-Memory Storage:

TaskStorage.tasks = dictionary: {task_id: Task_object}
Loaded on initialization from JSON file
All operations work on this in-memory dict first

Persistence:

Format: JSON file (tasks.json)
Write: Every create/update/delete triggers save()
Read: Only on TaskStorage.__init__() via load()

Serialization Magic:

TaskEncoder (storage.py:7-18): Converts Task objects ‚Üí JSON

Enums ‚Üí .value (int/string)
datetime ‚Üí .isoformat() (string)


TaskDecoder (storage.py:20-42): Converts JSON ‚Üí Task objects

Reconstructs Task from dict
Converts back: strings ‚Üí datetime, ints ‚Üí enums




Design Patterns Found

Layered Architecture (4-tier)

Presentation (CLI) ‚Üí Business Logic (TaskManager) ‚Üí Domain Model (Task) ‚Üí Data Access (TaskStorage)
Clean separation of concerns


Repository Pattern

TaskStorage acts as repository
Abstracts persistence details from business logic
All CRUD operations centralized


Enum Pattern

TaskPriority and TaskStatus prevent invalid values
Type-safe status/priority handling


Template Method Pattern (subtle)

Task.update() is generic method
Task.mark_as_done() is specialized version for specific use case


Custom JSON Encoding/Decoding

Extends json.JSONEncoder and json.JSONDecoder
Handles complex types (datetime, enums, custom objects)


UUID for IDs

Globally unique identifiers
No collision risk, good for distributed systems




Interesting Observations

Dual Update Path for Status:

mark_as_done() has special treatment (tracks completion time)
Other status updates use generic update() method
Why? Completion is a significant event worth timestamping


Eager Persistence:

Every mutation immediately writes to disk
Trade-off: Safety (no data loss) vs Performance (I/O overhead)


Date Validation in Two Places:

TaskManager.create_task() validates format
TaskManager.update_task_due_date() validates format
Could be DRY-ed up into helper method


Filter Methods in Storage Layer:

get_tasks_by_status(), get_tasks_by_priority(), get_overdue_tasks()
Could be replaced by single filter_tasks() with predicate
Current approach: explicit but repetitive


CODE UNDERSTANDING JOURNAL - Part 2: Task Prioritization System
Initial Understanding (Before Deep Dive)

app.py (TaskManager): Sets and updates task priority
models.py (Task): Stores priority value
storage.py (TaskStorage): Persists priority in JSON
cli.py (CLI): Lets user filter or update priority


Priority Levels Deep Dive
Available Priority Values:
pythonclass TaskPriority(Enum):
    LOW = 1
    MEDIUM = 2
    HIGH = 3
    URGENT = 4
```

**What they represent:**
- Each level indicates task urgency
- LOW (1) = least urgent
- URGENT (4) = most urgent

**Default Priority:**
- `TaskPriority.MEDIUM` (value 2)
- Set in `Task.__init__()` on line 17 of models.py

---

## **Priority Flow & Conversion**

### User Input ‚Üí Enum Conversion:
```
User types: -p 3
     ‚Üì
CLI receives: priority_value = 3 (integer)
     ‚Üì
app.py line 13: priority = TaskPriority(priority_value)
     ‚Üì
Result: TaskPriority.HIGH
Saving to JSON:
python# storage.py line 11 (TaskEncoder)
task_dict['priority'] = obj.priority.value

# Example: TaskPriority.HIGH ‚Üí 3 (stored as integer in JSON)
Loading from JSON:
python# storage.py line 25 (TaskDecoder)
task.priority = TaskPriority(obj['priority'])

# Example: 3 (from JSON) ‚Üí TaskPriority.HIGH
Key Insight: Priority is stored as numbers (1-4) in JSON, NOT as strings or ISO format

Priority Operations
Ways Users Interact with Priority:

Create with priority:

bash   python -m task_manager.cli create "Task" -p 3

Update priority:

bash   python -m task_manager.cli priority <task_id> 3

Filter by priority:

bash   python -m task_manager.cli list -p 3

View in statistics:

bash   python -m task_manager.cli stats
Validation in update_task_priority():
python# app.py lines 49-51
def update_task_priority(self, task_id, new_priority_value):
    new_priority = TaskPriority(new_priority_value)  # ‚Üê Validation happens here
    return self.storage.update_task(task_id, priority=new_priority)
What happens:

Converts integer to TaskPriority enum
If value is invalid (0, 5, 99, etc.) ‚Üí Raises ValueError
Python's Enum enforces only valid values (1-4)

Can priority be changed after creation?

‚úÖ YES! Using the priority command


Filtering & Display
How Filtering Works:
python# storage.py line 85
def get_tasks_by_priority(self, priority):
    return [task for task in self.tasks.values() if task.priority == priority]

Searches in-memory dictionary (not JSON file)
List comprehension filters tasks matching the priority

Display Symbols (CLI):
python# cli.py lines 12-17
priority_symbol = {
    TaskPriority.LOW: "!",
    TaskPriority.MEDIUM: "!!",
    TaskPriority.HIGH: "!!!",
    TaskPriority.URGENT: "!!!!"
}
Visual representation:

LOW = !
MEDIUM = !!
HIGH = !!!
URGENT = !!!!


Statistics & Priority Counting
Is Priority Included in Stats?
‚úÖ YES!
python# app.py lines 77-79
priority_counts = {priority.value: 0 for priority in TaskPriority}
for task in tasks:
    priority_counts[task.priority.value] += 1
What get_statistics() Returns:
python{
    "total": 15,
    "by_status": {"todo": 5, "in_progress": 3, "review": 2, "done": 5},
    "by_priority": {1: 2, 2: 8, 3: 4, 4: 1},  # ‚Üê Priority counts
    "overdue": 2,
    "completed_last_week": 3
}
Return type: Dictionary (not True/False, not string)

Design Decisions
Why Use Enum Instead of Just Numbers?
Advantages:

Type Safety

Can't accidentally use invalid values
TaskPriority(5) ‚Üí crashes immediately with clear error


Readability

TaskPriority.HIGH is clearer than 3
Self-documenting code


Easier Conversion

.value property for serialization
Constructor for deserialization
One-line conversions: TaskPriority(3) or priority.value


Maintainability

Can change underlying values without changing code
Can add/remove levels easily


IDE Support

Autocomplete shows available options
Type checking catches errors



What Happens with Invalid Values?
Scenario: User tries priority 5 or priority 0
pythonTaskPriority(5)  # Raises: ValueError: 5 is not a valid TaskPriority
```

- Python's `Enum` automatically validates
- Only accepts: 1, 2, 3, 4
- Any other value ‚Üí immediate crash with clear error message

---

## **Key Differences: Priority vs Dates**

| Aspect | Priority | Dates |
|--------|----------|-------|
| **Storage in JSON** | Integer (1-4) | ISO string ("2024-12-25T10:30:00") |
| **Python Type** | TaskPriority enum | datetime object |
| **Encoding** | `.value` property | `.isoformat()` method |
| **Decoding** | `TaskPriority(int)` | `datetime.fromisoformat(str)` |

**Common Confusion:** Priority is NOT stored as ISO strings!

---

## **Complete Priority Data Flow**
```
CLI Input: -p 3
     ‚Üì
TaskManager receives: priority_value=3 (int)
     ‚Üì
Converts to: TaskPriority.HIGH (enum)
     ‚Üì
Task object stores: self.priority = TaskPriority.HIGH
     ‚Üì
TaskEncoder converts: priority.value ‚Üí 3 (int)
     ‚Üì
JSON file stores: "priority": 3
     ‚Üì
On load, TaskDecoder: TaskPriority(3) ‚Üí TaskPriority.HIGH
     ‚Üì
Back in memory as enum!

Summary of Learning
What I Learned:

Priority uses Enum pattern for type safety
Stored as integers in JSON, not strings
Four operations: create, update, filter, view stats
Validation happens through enum conversion (auto-rejects invalid values)
Display symbols use exclamation marks (!, !!, !!!, !!!!)
Statistics count tasks by priority level
In-memory filtering (not at storage level)

Design Patterns Reinforced:

Enum Pattern (type safety)
Custom JSON serialization/deserialization
Repository pattern (TaskStorage abstracts persistence)
Layered architecture (CLI ‚Üí Manager ‚Üí Model ‚Üí Storage)


 - Data Flow Mapping

MAIN DATA FLOW DIAGRAM
                    üë§ USER
                     ‚îÇ
                     ‚îÇ Command: python cli.py status abc123 done
                     ‚îÇ
                     ‚Üì
    ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
    ‚ïë              üñ•Ô∏è  CLI LAYER (cli.py)                ‚ïë
    ‚ïë                                                    ‚ïë
    ‚ïë  üìã Parse Command Arguments                        ‚ïë
    ‚ïë     ‚Ä¢ task_id = "abc123"                          ‚ïë
    ‚ïë     ‚Ä¢ status = "done"                             ‚ïë
    ‚ïë                                                    ‚ïë
    ‚ïë  ‚öôÔ∏è  Action: Call task_manager.update_task_status()‚ïë
    ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
                     ‚îÇ
                     ‚îÇ
                     ‚Üì
    ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
    ‚ïë         üß† BUSINESS LOGIC (app.py)                 ‚ïë
    ‚ïë            TaskManager Class                       ‚ïë
    ‚ïë                                                    ‚ïë
    ‚ïë  1Ô∏è‚É£  Convert: "done" ‚Üí TaskStatus.DONE (enum)     ‚ïë
    ‚ïë                                                    ‚ïë
    ‚ïë  2Ô∏è‚É£  Check: Is status == DONE?                    ‚ïë
    ‚ïë       ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄYES‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                             ‚ïë
    ‚ïë       ‚Üì             ‚Üì                             ‚ïë
    ‚ïë  [Special Path]  [Normal Path]                    ‚ïë
    ‚ïë   for "DONE"     for others                       ‚ïë
    ‚ïë                                                    ‚ïë
    ‚ïë  3Ô∏è‚É£  Get task from storage                        ‚ïë
    ‚ïë       ‚îú‚îÄ Found? ‚úÖ Continue                        ‚ïë
    ‚ïë       ‚îî‚îÄ Not found? ‚ùå Return False                ‚ïë
    ‚ïë                                                    ‚ïë
    ‚ïë  4Ô∏è‚É£  Call: task.mark_as_done()                    ‚ïë
    ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
                     ‚îÇ
                     ‚îÇ
                     ‚Üì
    ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
    ‚ïë          üì¶ MODEL LAYER (models.py)                ‚ïë
    ‚ïë              Task Class                            ‚ïë
    ‚ïë                                                    ‚ïë
    ‚ïë  üîÑ STATE CHANGES IN MEMORY:                       ‚ïë
    ‚ïë                                                    ‚ïë
    ‚ïë  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê         ‚ïë
    ‚ïë  ‚îÇ ‚úèÔ∏è  self.status = TaskStatus.DONE     ‚îÇ         ‚ïë
    ‚ïë  ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§         ‚ïë
    ‚ïë  ‚îÇ ‚è∞ self.completed_at = datetime.now() ‚îÇ         ‚ïë
    ‚ïë  ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§         ‚ïë
    ‚ïë  ‚îÇ üìÖ self.updated_at = datetime.now()   ‚îÇ         ‚ïë
    ‚ïë  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò         ‚ïë
    ‚ïë                                                    ‚ïë
    ‚ïë  Task object now updated in RAM                    ‚ïë
    ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
                     ‚îÇ
                     ‚îÇ
                     ‚Üì
    ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
    ‚ïë        üíæ STORAGE LAYER (storage.py)               ‚ïë
    ‚ïë           TaskStorage Class                        ‚ïë
    ‚ïë                                                    ‚ïë
    ‚ïë  üîß Serialization Process:                         ‚ïë
    ‚ïë                                                    ‚ïë
    ‚ïë  1. TaskEncoder transforms:                        ‚ïë
    ‚ïë     ‚Ä¢ TaskStatus.DONE ‚Üí "done"                    ‚ïë
    ‚ïë     ‚Ä¢ datetime object ‚Üí "2024-02-06T14:30:00"     ‚ïë
    ‚ïë                                                    ‚ïë
    ‚ïë  2. json.dump() writes ALL tasks                   ‚ïë
    ‚ïë                                                    ‚ïë
    ‚ïë  3. File write with indent=2 (pretty format)       ‚ïë
    ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
                     ‚îÇ
                     ‚îÇ
                     ‚Üì
    ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
    ‚ïë          üíø PERSISTENT STORAGE                     ‚ïë
    ‚ïë            tasks.json file                         ‚ïë
    ‚ïë                                                    ‚ïë
    ‚ïë  {                                                 ‚ïë
    ‚ïë    "id": "abc123",                                ‚ïë
    ‚ïë    "title": "Buy milk",                           ‚ïë
    ‚ïë    "status": "done",              ‚úÖ SAVED        ‚ïë
    ‚ïë    "completed_at": "2024-02-06T14:30:00", ‚úÖ      ‚ïë
    ‚ïë    "updated_at": "2024-02-06T14:30:00",   ‚úÖ      ‚ïë
    ‚ïë    "created_at": "2024-02-01T09:00:00",           ‚ïë
    ‚ïë    "priority": 2,                                 ‚ïë
    ‚ïë    "due_date": "2024-02-07T00:00:00"             ‚ïë
    ‚ïë  }                                                 ‚ïë
    ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
                     ‚îÇ
                     ‚îÇ
                     ‚Üì
    ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
    ‚ïë              ‚úÖ SUCCESS RESPONSE                   ‚ïë
    ‚ïë                                                    ‚ïë
    ‚ïë  Return True ‚Üí CLI                                 ‚ïë
    ‚ïë  Print: "Updated task status to done"             ‚ïë
    ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

DETAILED STEP-BY-STEP FLOW
START: User executes command
  ‚îÇ
  ‚îú‚îÄ‚Üí [1] CLI Parsing
  ‚îÇ    ‚îÇ
  ‚îÇ    ‚îú‚îÄ Input: "python cli.py status abc123 done"
  ‚îÇ    ‚îú‚îÄ Parse: argparse processes arguments
  ‚îÇ    ‚îî‚îÄ Output: task_id="abc123", status="done"
  ‚îÇ
  ‚îú‚îÄ‚Üí [2] TaskManager.update_task_status()
  ‚îÇ    ‚îÇ
  ‚îÇ    ‚îú‚îÄ Convert: "done" ‚Üí TaskStatus.DONE (enum)
  ‚îÇ    ‚îÇ
  ‚îÇ    ‚îú‚îÄ Decision: Is status == DONE?
  ‚îÇ    ‚îÇ            ‚îå‚îÄ YES ‚îÄ‚îê
  ‚îÇ    ‚îÇ            ‚îÇ       ‚îÇ
  ‚îÇ    ‚îÇ            ‚Üì       ‚Üì
  ‚îÇ    ‚îÇ      [Special Path] [Normal Path]
  ‚îÇ    ‚îÇ      Go to step 3   Go to step 4
  ‚îÇ    ‚îÇ
  ‚îÇ    ‚îî‚îÄ [3] Special "DONE" Handling
  ‚îÇ         ‚îÇ
  ‚îÇ         ‚îú‚îÄ Get task: storage.get_task(task_id)
  ‚îÇ         ‚îÇ            ‚îÇ
  ‚îÇ         ‚îÇ            ‚îú‚îÄ Found? ‚Üí Continue
  ‚îÇ         ‚îÇ            ‚îî‚îÄ Not found? ‚Üí Return False ‚ùå
  ‚îÇ         ‚îÇ
  ‚îÇ         ‚îú‚îÄ Call: task.mark_as_done()
  ‚îÇ         ‚îú‚îÄ Call: storage.save()
  ‚îÇ         ‚îî‚îÄ Return: True ‚úÖ
  ‚îÇ
  ‚îú‚îÄ‚Üí [4] Task.mark_as_done()
  ‚îÇ    ‚îÇ
  ‚îÇ    ‚îú‚îÄ STATE CHANGE 1: self.status = TaskStatus.DONE
  ‚îÇ    ‚îú‚îÄ STATE CHANGE 2: self.completed_at = datetime.now()
  ‚îÇ    ‚îî‚îÄ STATE CHANGE 3: self.updated_at = datetime.now()
  ‚îÇ
  ‚îú‚îÄ‚Üí [5] TaskStorage.save()
  ‚îÇ    ‚îÇ
  ‚îÇ    ‚îú‚îÄ Open file: tasks.json (write mode)
  ‚îÇ    ‚îÇ
  ‚îÇ    ‚îú‚îÄ Serialize: json.dump() with TaskEncoder
  ‚îÇ    ‚îÇ              ‚îÇ
  ‚îÇ    ‚îÇ              ‚îú‚îÄ For each task:
  ‚îÇ    ‚îÇ              ‚îÇ   ‚îú‚îÄ Convert enums to values
  ‚îÇ    ‚îÇ              ‚îÇ   ‚îî‚îÄ Convert datetime to ISO strings
  ‚îÇ    ‚îÇ              ‚îÇ
  ‚îÇ    ‚îÇ              ‚îî‚îÄ Write pretty JSON (indent=2)
  ‚îÇ    ‚îÇ
  ‚îÇ    ‚îî‚îÄ Close file
  ‚îÇ
  ‚îî‚îÄ‚Üí [6] Return to CLI
       ‚îÇ
       ‚îú‚îÄ If success: Print "Updated task status to done"
       ‚îî‚îÄ If failure: Print "Failed to update task status"
  
END

STATE TRANSITION VISUAL
    BEFORE COMPLETION          ‚Üí         AFTER COMPLETION
    
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê              ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  üìã Task Object     ‚îÇ              ‚îÇ  ‚úÖ Task Object     ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§              ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ status: TODO        ‚îÇ  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚Üí   ‚îÇ status: DONE        ‚îÇ
‚îÇ completed_at: null  ‚îÇ              ‚îÇ completed_at: NOW   ‚îÇ
‚îÇ updated_at: old     ‚îÇ              ‚îÇ updated_at: NOW     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò              ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         IN RAM                               IN RAM
            ‚îÇ                                    ‚îÇ
            ‚îÇ                                    ‚îÇ
            ‚Üì                                    ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê              ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  üíæ tasks.json      ‚îÇ              ‚îÇ  üíæ tasks.json      ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§              ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ "status": "todo"    ‚îÇ  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚Üí   ‚îÇ "status": "done"    ‚îÇ
‚îÇ "completed_at": null‚îÇ              ‚îÇ "completed_at": ISO ‚îÇ
‚îÇ "updated_at": ISO   ‚îÇ              ‚îÇ "updated_at": ISO   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò              ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
        ON DISK                             ON DISK

STATE CHANGES DURING TASK COMPLETION
In-Memory Changes (Task Object)
FieldBeforeAfterNotesstatusTaskStatus.TODO (or IN_PROGRESS/REVIEW)TaskStatus.DONEEnum value changedcompleted_atNonedatetime.now()‚≠ê Only set on completionupdated_atPrevious timestampSame as completed_atAlways updatedtitleUnchangedUnchanged-descriptionUnchangedUnchanged-priorityUnchangedUnchanged-due_dateUnchangedUnchanged-created_atUnchangedUnchanged-tagsUnchangedUnchanged-
Persistent Changes (tasks.json)
Before:
json{
  "id": "abc123",
  "title": "Buy milk",
  "status": "todo",
  "completed_at": null,
  "updated_at": "2024-02-05T10:00:00",
  "priority": 2
}
After:
json{
  "id": "abc123",
  "title": "Buy milk",
  "status": "done",                      ‚úÖ CHANGED
  "completed_at": "2024-02-06T14:30:00", ‚úÖ CHANGED
  "updated_at": "2024-02-06T14:30:00",   ‚úÖ CHANGED
  "priority": 2
}
```

---

## **POTENTIAL POINTS OF FAILURE**
```
                     [START]
                        ‚îÇ
                        ‚Üì
            ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
            ‚îÇ   ‚ùå FAILURE POINT 1   ‚îÇ
            ‚îÇ   Invalid task ID     ‚îÇ
            ‚îÇ   ‚Üí Returns False     ‚îÇ
            ‚îÇ   ‚Üí Graceful handling ‚îÇ
            ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                        ‚îÇ ‚úÖ Valid ID
                        ‚Üì
            ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
            ‚îÇ   ‚ùå FAILURE POINT 2   ‚îÇ
            ‚îÇ   Invalid status      ‚îÇ
            ‚îÇ   ‚Üí ValueError        ‚îÇ
            ‚îÇ   ‚Üí CRASH üí•          ‚îÇ
            ‚îÇ   ‚Üí UNHANDLED         ‚îÇ
            ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                        ‚îÇ ‚úÖ Valid status
                        ‚Üì
            [ State Change in Memory ]
                        ‚îÇ
                        ‚Üì
            ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
            ‚îÇ   ‚ùå FAILURE POINT 3   ‚îÇ
            ‚îÇ   File permission     ‚îÇ
            ‚îÇ   denied              ‚îÇ
            ‚îÇ   ‚Üí Exception caught  ‚îÇ
            ‚îÇ   ‚Üí Error printed     ‚îÇ
            ‚îÇ   ‚Üí DATA LOST ‚ö†Ô∏è      ‚îÇ
            ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                        ‚îÇ ‚úÖ Can write
                        ‚Üì
            ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
            ‚îÇ   ‚ùå FAILURE POINT 4   ‚îÇ
            ‚îÇ   Disk full           ‚îÇ
            ‚îÇ   ‚Üí Partial write     ‚îÇ
            ‚îÇ   ‚Üí Corrupted file üí• ‚îÇ
            ‚îÇ   ‚Üí ALL DATA LOST     ‚îÇ
            ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                        ‚îÇ ‚úÖ Write success
                        ‚Üì
            ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
            ‚îÇ   ‚ùå FAILURE POINT 5   ‚îÇ
            ‚îÇ   Race condition      ‚îÇ
            ‚îÇ   ‚Üí Concurrent writes ‚îÇ
            ‚îÇ   ‚Üí Last write wins   ‚îÇ
            ‚îÇ   ‚Üí Data overwritten  ‚îÇ
            ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                        ‚îÇ ‚úÖ No conflicts
                        ‚Üì
                   [SUCCESS] ‚úÖ
Detailed Failure Analysis
1. Invalid Task ID (Line 40 - app.py)
pythontask = self.storage.get_task(task_id)
if task:  # ‚Üê Protection here

Failure: User provides non-existent task_id
Impact: LOW - Gracefully handled
Result: Returns False, user sees "Failed to update"
Protection: ‚úÖ if task check prevents crash

2. Invalid Status Value (Line 38 - app.py)
pythonnew_status = TaskStatus(new_status_value)

Failure: User provides invalid status (e.g., "complete" instead of "done")
Impact: HIGH - Unhandled exception
Result: ValueError crashes the program
Protection: ‚ùå None - should add try/except

3. File System Errors (Line 59 - storage.py)
pythonwith open(self.storage_path, 'w') as f:

Failures:

Permission denied (read-only filesystem)
Disk full (no space left)
Path doesn't exist
File locked by another process


Impact: CRITICAL - Data loss
Result: Task marked done in memory, but not saved to disk
Protection: ‚ö†Ô∏è Partial - Exception caught but data still lost

4. JSON Serialization Errors (Line 60 - storage.py)
pythonjson.dump(list(self.tasks.values()), f, cls=TaskEncoder, indent=2)
```
- **Failures:**
  - Corrupted task object
  - Circular references
  - Unserializable data type
- **Impact:** CRITICAL - Data loss
- **Result:** File partially written or corrupted
- **Protection:** ‚ö†Ô∏è Partial - Exception caught but data lost

**5. Race Conditions (No protection)**
- **Scenario:** 
  - Process A loads tasks.json at 14:30:00
  - Process B loads tasks.json at 14:30:01
  - Process A marks task X as done, saves at 14:30:02
  - Process B updates priority of task Y, saves at 14:30:03
  - Process B's save overwrites A's changes!
- **Impact:** MEDIUM - Silent data corruption
- **Result:** Last write wins, previous changes lost
- **Protection:** ‚ùå None - no file locking or transaction support

**6. Power Loss / Crash During Write**
- **Scenario:** Power failure while writing JSON file
- **Impact:** CATASTROPHIC - Complete data loss
- **Result:** Corrupted or empty tasks.json file
- **Protection:** ‚ùå None - no atomic writes or backups

---

## **HOW CHANGES ARE PERSISTED**

### **Persistence Strategy**
```
In-Memory Change ‚Üí save() called ‚Üí Full serialization ‚Üí File write
     (instant)        (instant)      (milliseconds)     (milliseconds)
```

### **Key Characteristics:**

**1. Immediate (Eager) Persistence**
- Every state change immediately triggers save()
- No batching or delayed writes
- No write-back cache

**2. Full File Overwrite**
- Entire `tasks` dictionary serialized every time
- Complete file rewrite (not incremental/append)
- All tasks written, even if only one changed

**3. JSON Format**
- Human-readable text format
- Pretty-printed with `indent=2`
- Larger file size but easier debugging

**4. No Transaction Support**
- No rollback capability
- No commit/abort operations
- All-or-nothing write

**5. No Atomic Operations**
- File write not atomic
- Partial writes possible
- No write-ahead logging

### **Persistence Flow Diagram**
```
    PYTHON OBJECTS              SERIALIZATION           JSON FILE
    
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                                  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ Task Object ‚îÇ            TaskEncoder           ‚îÇ   String    ‚îÇ
    ‚îÇ             ‚îÇ  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚Üí     ‚îÇ Representation‚îÇ
    ‚îÇ ‚Ä¢ Enums     ‚îÇ                                  ‚îÇ             ‚îÇ
    ‚îÇ ‚Ä¢ datetime  ‚îÇ   Convert enums to values        ‚îÇ ‚Ä¢ "done"    ‚îÇ
    ‚îÇ ‚Ä¢ Objects   ‚îÇ   Convert datetime to ISO        ‚îÇ ‚Ä¢ "2024..." ‚îÇ
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   Create dictionary              ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                          ‚Üì
                   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                   ‚îÇ json.dump() ‚îÇ
                   ‚îÇ  indent=2   ‚îÇ
                   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                          ‚Üì
                   [ Write to File ]
                          ‚Üì
                    tasks.json üíæ
```

### **Advantages:**
- ‚úÖ Simple implementation
- ‚úÖ Easy to understand and debug
- ‚úÖ Data always fresh (no stale cache)
- ‚úÖ Human-readable format

### **Disadvantages:**
- ‚ùå Slow for large task lists (rewrites everything)
- ‚ùå No transaction support (can't rollback)
- ‚ùå Vulnerable to partial writes (power loss)
- ‚ùå No concurrent access protection (race conditions)
- ‚ùå No backup mechanism
- ‚ùå File I/O on every change (performance impact)

---

## **TWO PATHS COMPARISON: "DONE" VS OTHER STATUSES**
```
        UPDATE STATUS TO "DONE"          ‚îÇ    UPDATE TO OTHER STATUS
                                         ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ         SPECIAL PATH              ‚îÇ    ‚îÇ  ‚îÇ        NORMAL PATH            ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§    ‚îÇ  ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                  ‚îÇ    ‚îÇ  ‚îÇ                              ‚îÇ
‚îÇ  1. Get task from storage        ‚îÇ    ‚îÇ  ‚îÇ  1. Call storage.update_task ‚îÇ
‚îÇ                                  ‚îÇ    ‚îÇ  ‚îÇ                              ‚îÇ
‚îÇ  2. task.mark_as_done()          ‚îÇ    ‚îÇ  ‚îÇ  2. Get task                 ‚îÇ
‚îÇ     ‚îú‚îÄ status = DONE             ‚îÇ    ‚îÇ  ‚îÇ                              ‚îÇ
‚îÇ     ‚îú‚îÄ completed_at = NOW ‚≠ê     ‚îÇ    ‚îÇ  ‚îÇ  3. task.update(status=...)  ‚îÇ
‚îÇ     ‚îî‚îÄ updated_at = NOW          ‚îÇ    ‚îÇ  ‚îÇ     ‚îú‚îÄ status = NEW_STATUS   ‚îÇ
‚îÇ                                  ‚îÇ    ‚îÇ  ‚îÇ     ‚îî‚îÄ updated_at = NOW      ‚îÇ
‚îÇ  3. storage.save()               ‚îÇ    ‚îÇ  ‚îÇ                              ‚îÇ
‚îÇ                                  ‚îÇ    ‚îÇ  ‚îÇ  4. storage.save()           ‚îÇ
‚îÇ  4. Return True                  ‚îÇ    ‚îÇ  ‚îÇ                              ‚îÇ
‚îÇ                                  ‚îÇ    ‚îÇ  ‚îÇ  5. Return True              ‚îÇ
‚îÇ                                  ‚îÇ    ‚îÇ  ‚îÇ                              ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§    ‚îÇ  ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  FIELDS CHANGED: 3               ‚îÇ    ‚îÇ  ‚îÇ  FIELDS CHANGED: 2           ‚îÇ
‚îÇ  ‚Ä¢ status                        ‚îÇ    ‚îÇ  ‚îÇ  ‚Ä¢ status                    ‚îÇ
‚îÇ  ‚Ä¢ completed_at ‚≠ê               ‚îÇ    ‚îÇ  ‚îÇ  ‚Ä¢ updated_at                ‚îÇ
‚îÇ  ‚Ä¢ updated_at                    ‚îÇ    ‚îÇ  ‚îÇ                              ‚îÇ
‚îÇ                                  ‚îÇ    ‚îÇ  ‚îÇ                              ‚îÇ
‚îÇ  üéØ Records completion time!     ‚îÇ    ‚îÇ  ‚îÇ  üéØ No completion tracking   ‚îÇ
‚îÇ  üéØ Business significance        ‚îÇ    ‚îÇ  ‚îÇ  üéØ Simple state change      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### **Why "DONE" is Special:**

1. **Completion is a significant business event**
   - Marks task lifecycle endpoint
   - Worth timestamping for analytics

2. **completed_at field only set once**
   - Tracks when work was finished
   - Used for statistics (tasks completed last week)

3. **Reflects business logic**
   - Completion is final state
   - Other statuses are transitional

4. **Dedicated method shows intent**
   - `mark_as_done()` is clear and explicit
   - Better than generic `update(status=DONE)`

---

## **LAYERED ARCHITECTURE VISUAL**
```
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ          PRESENTATION LAYER                 ‚îÇ  ‚Üê User interaction
    ‚îÇ              (cli.py)                       ‚îÇ
    ‚îÇ  ‚Ä¢ Argument parsing                         ‚îÇ
    ‚îÇ  ‚Ä¢ User input/output                        ‚îÇ
    ‚îÇ  ‚Ä¢ Command routing                          ‚îÇ
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                        ‚îÇ
                        ‚Üì
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ         BUSINESS LOGIC LAYER                ‚îÇ  ‚Üê Orchestration
    ‚îÇ           (app.py - TaskManager)            ‚îÇ
    ‚îÇ  ‚Ä¢ Validation                               ‚îÇ
    ‚îÇ  ‚Ä¢ Workflow coordination                    ‚îÇ
    ‚îÇ  ‚Ä¢ Business rules                           ‚îÇ
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                        ‚îÇ
                        ‚Üì
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ           DOMAIN MODEL LAYER                ‚îÇ  ‚Üê Business entities
    ‚îÇ            (models.py - Task)               ‚îÇ
    ‚îÇ  ‚Ä¢ Task behavior                            ‚îÇ
    ‚îÇ  ‚Ä¢ State management                         ‚îÇ
    ‚îÇ  ‚Ä¢ Business logic methods                   ‚îÇ
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                        ‚îÇ
                        ‚Üì
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ          DATA ACCESS LAYER                  ‚îÇ  ‚Üê Persistence
    ‚îÇ        (storage.py - TaskStorage)           ‚îÇ
    ‚îÇ  ‚Ä¢ Serialization                            ‚îÇ
    ‚îÇ  ‚Ä¢ File I/O                                 ‚îÇ
    ‚îÇ  ‚Ä¢ Data retrieval                           ‚îÇ
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                        ‚îÇ
                        ‚Üì
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ              PERSISTENCE                    ‚îÇ  ‚Üê Storage
    ‚îÇ              (tasks.json)                   ‚îÇ
    ‚îÇ  ‚Ä¢ JSON file on disk                        ‚îÇ
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## **QUICK REFERENCE SUMMARY**
```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  üìå DATA FLOW SUMMARY                                      ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                            ‚îÇ
‚îÇ  1Ô∏è‚É£  CLI captures: task_id + "done"                       ‚îÇ
‚îÇ  2Ô∏è‚É£  TaskManager validates & routes to special path       ‚îÇ
‚îÇ  3Ô∏è‚É£  Task updates 3 fields in memory                      ‚îÇ
‚îÇ  4Ô∏è‚É£  Storage serializes & writes entire file              ‚îÇ
‚îÇ  5Ô∏è‚É£  Returns success/failure to user                      ‚îÇ
‚îÇ                                                            ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  üîÑ STATE CHANGES                                          ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                            ‚îÇ
‚îÇ  ‚Ä¢ status      ‚Üí TaskStatus.DONE                          ‚îÇ
‚îÇ  ‚Ä¢ completed_at ‚Üí datetime.now()  ‚≠ê Special!             ‚îÇ
‚îÇ  ‚Ä¢ updated_at  ‚Üí datetime.now()                           ‚îÇ
‚îÇ                                                            ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  ‚ö†Ô∏è  FAILURE POINTS                                        ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                            ‚îÇ
‚îÇ  ‚ùå Invalid task ID ‚Üí Graceful (returns False)             ‚îÇ
‚îÇ  ‚ùå Invalid status ‚Üí Crash (ValueError, unhandled)         ‚îÇ
‚îÇ  ‚ùå File I/O error ‚Üí Data lost (exception caught)          ‚îÇ
‚îÇ  ‚ùå Disk full ‚Üí Corrupted file (catastrophic)              ‚îÇ
‚îÇ  ‚ùå Race conditions ‚Üí Data overwritten (no locking)        ‚îÇ
‚îÇ  ‚ùå Power loss ‚Üí Complete data loss (no atomicity)         ‚îÇ
‚îÇ                                                            ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  üíæ PERSISTENCE STRATEGY                                   ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                            ‚îÇ
‚îÇ  ‚Ä¢ Immediate (eager) persistence                          ‚îÇ
‚îÇ  ‚Ä¢ Full file overwrite (not incremental)                  ‚îÇ
‚îÇ  ‚Ä¢ JSON format (human-readable, larger files)             ‚îÇ
‚îÇ  ‚Ä¢ No transaction support                                 ‚îÇ
‚îÇ  ‚Ä¢ No atomic writes                                       ‚îÇ
‚îÇ  ‚Ä¢ No concurrency control                                 ‚îÇ
‚îÇ  ‚Ä¢ No backup mechanism                                    ‚îÇ
‚îÇ                                                            ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

KEY INSIGHTS

Layered Architecture: Clean separation of concerns across 4 layers
Special "DONE" Treatment: Completion gets its own method and timestamp
Immediate Persistence: Every change immediately written to disk
Vulnerable Points: Multiple failure scenarios with varying severity
Simple but Risky: Easy to understand but lacks robustness features
Full Rewrites: Inefficient for large datasets but simple to implement



TESTING SUMMARY - Quick Reference

HOW TO RUN TESTS
Method 1: Run specific test file
bashpython -m unittest tests.test_basic -v
Method 2: Discover and run all tests
bashpython -m unittest discover -s tests -v
Method 3: Run without verbose output
bashpython -m unittest discover -s tests
```

---

## **SUCCESSFUL TEST OUTPUT**
```
test_simple (tests.test_basic.TestBasic)
A simple test to verify testing works ... ok

----------------------------------------------------------------------
Ran 1 test in 0.001s

OK

IF YOU GET "Ran 0 tests"
Check 1: Does test file have content?
bashcat tests/test_basic.py
wc -l tests/test_basic.py
If empty (0 lines): Add test code ‚¨áÔ∏è

ADDING TEST CODE TO EMPTY FILE
bashcat > tests/test_basic.py << 'EOF'
import unittest

class TestBasic(unittest.TestCase):
    def test_simple(self):
        """A simple test to verify testing works"""
        self.assertEqual(1 + 1, 2)

if __name__ == '__main__':
    unittest.main()
EOF

VERIFY IT WORKED
bash# Check file has content
cat tests/test_basic.py

# Run test
python -m unittest tests.test_basic -v

KEY REQUIREMENTS
‚úÖ tests/ folder exists
‚úÖ tests/__init__.py exists (can be empty)
‚úÖ Test files start with test_*.py
‚úÖ Test class inherits from unittest.TestCase
‚úÖ Test methods start with test_

QUICK TROUBLESHOOTING
ProblemSolution"Start directory is not importable"Create tests/__init__.py"Ran 0 tests"Check if test file is emptyTest file emptyAdd test code using cat > command above